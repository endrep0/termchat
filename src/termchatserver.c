#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#define PORT "1122"
#define MAX_CHAT_CLIENTS 15

// sockets to give to select
FD_SET socks_to_process;
// this array will hold the connected client sockets
int connected_client_socks[MAX_CHAT_CLIENTS];

// creates the list of sockets that select needs to iterate through
// to be called from the main loop
void BuildSelectList() {
	// empty the set
	FD_ZERO(&socks_to_process);
	
	// add the server socket
	FD_SET(server_socket, &socks_to_process);
	
	// add the client sockets which are connected
	for(int i=0; i<MAX_CHAT_CLIENTS; i++) 
		if (NULL != connected_client_socks[i]) 
			FD_SET(connected_client_socks[i],&socks_to_process)	
}

int main() {
	struct addrinfo hints;
	struct addrinfo* res;
	int err;
	struct sockaddr_in6 addr;
	socklen_t addrlen;
	char ips[NI_MAXHOST];
	char servs[NI_MAXSERV];
	int server_socket, csock;
	char buf[256];
	int len;
	int reuse;
	const char msg_server_full[]="Sorry, the chat server is currently full. Try again later.\n";


	
	// timeout for select
	struct timeval select_timeout;
	int num_of_sockets_to_read;
	
	// A címhez kötéshez össze kell állítani a lokális címet, amit a getaddrinfo() függvénnyel fogunk elvégezni.
	// Az AI_PASSIVE flag haására a címeket INADDR_ANY vagy in6addr_any-vel tölti fel.
	// Beállítandó hints.ai_flags, hints.ai_family, hints.ai_socktype
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_flags = AI_PASSIVE;
	hints.ai_socktype = SOCK_STREAM;

	
	// int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);
	err = getaddrinfo(NULL, PORT, &hints, &res);
	if(err != 0) {
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(err));
		return -1;
	}

	if(res == NULL) return -1;
	
	// Létrehozzuk a server socketet getaddrinfo() válasza alapján
	// int socket(int domain, int type, int protocol);
	server_socket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (server_socket < 0) {
	  perror("socket");
	  return -1;
	}

	// we allow reusing of sockets (SO_REUSEADDR). Socket level (SOL_SOCKET)
	// int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
	reuse = 1;
	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
	// set the socket to non-blocking
	int opts = fcntl(server_socket, F_GETFL);
	opts = (opts | O_NONBLOCK);
	fcntl(server_socket, F_SETFL, opts);
	
	// bind the server socket to the address, based on the reply of getaddrinfo()
	// int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	if (bind(server_socket, res->ai_addr, res->ai_addrlen) < 0) {
	  perror("bind");
	  return -1;
	}

	// let's listen for a connection
	// int listen(int sockfd, int backlog);
	if(listen(server_socket, 5) < 0) {
		perror("listen");
		return 1;
	}
	
	// we don't need the address linked list generated by getadrrinfo() anymore
	freeaddrinfo(res);
	
	// allocate memory for the client socket list
	memset((char *) &connected_client_socks, 0, sizeof(connected_client_socks));

	// main loop, we iterate through the sockets
	// accept connections if needed, read them if needed, giving them a small timeout	
	while (1)
	{
		BuildSelectList();
		select_timeout.tv_sec = 1;
		select_timeout.tv_usec = 0;
		// run the select. it will return if 
		// a) it can read from the set of sockets in socks_to_process (or EOF if disconnected)
		// b) after timeout
		num_of_sockets_to_read = select(FD_SETSIZE, &socks_to_process, (fd_set *) 0, (fd_set *) 0, &select_timeout);
		
		// select has modified socks_to_process, only those remain which can be read without blocking
		if (0 == num_of_sockets_to_read) {
			printf("No sockets to read.\n");
			fflush(stdout);
		}
		else {
			ProcessSocketsToRead();
		}
		
		
		
		// Cím hosszának beállítása sizeof()-fal
		addrlen = sizeof(addr);
		// Fogadjuk a kapcsolodasokat. csock lesz a kliens socket*/
		// int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
		while((csock = accept(server_socket, (struct sockaddr*)&addr, &addrlen)) >=0) {
			// using getnameinfo(), to get client's ip:port string in a protocol independent way
			// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, szie_t servlen, int flags);
			if (getnameinfo((struct sockaddr*)&addr, addrlen, ips, sizeof(ips), servs, sizeof(servs), 0) == 0) {
				printf("Chat client connection from: %s:%s\n", ips, servs);
			}
			// fogadjuk a beérkező csomagokat, és kiírjuk a tartalmát a képernyőre
			// ssize_t recv(int sockfd, void *buf, size_t len, int flags);
			while((len = recv(csock, buf, sizeof(buf), 0)) > 0) {
				write(STDOUT_FILENO, buf, len);
			}
			printf("Connection closed.\n");
			
			// lezárjuk a kliens socketet
			// int close(int fd);
			close(csock);
		}
		
		// lezárjuk a szerver socketet
		// int close(int fd);
		close(server_socket);
	}
	
	
	return 0;
}


