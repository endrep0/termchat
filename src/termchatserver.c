/* this project is created as a school assignment by Endre Palinkas */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <openssl/evp.h>
#include "termchatcommon.h"
#include "termchatserver.h"

int server_socket;
char buffer[MAX_SOCKET_BUF];
char msg_to_send[MAX_SOCKET_BUF];
char reply[MAX_SOCKET_BUF];
// for custom behavior on SIGTERM
struct sigaction new_signal_action;
// sockets to give to select
fd_set socks_to_process;
// for storing the connected clients' data
chat_client_t chat_clients[MAX_CHAT_CLIENTS];
// saved nick passwords (hashes)
passwords_t passwords[MAX_SAVED_PASSWORDS];

int main(int argc, char *argv[]) {
	int i, err, reuse;
	struct timeval select_timeout;
	int num_of_sockets_to_read;
	struct addrinfo hints;
	struct addrinfo* res;
	
	// did we get port as parameter
	if(argc != 2) {
		printf("Usage: %s <port to listen on>\n", argv[0]);
		return -1;
	}
	// let's assemble the local address, which is needed for the binding. we will use getaddrinfo() for this
	// AI_PASSIVE, so the addresses will be INADDR_ANY or IN6ADDR_ANY
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_flags = AI_PASSIVE;
	hints.ai_socktype = SOCK_STREAM;

	
	// int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);
	err = getaddrinfo(NULL, argv[1], &hints, &res);
	if(err != 0) {
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(err));
		return -1;
	}

	if(res == NULL) {
		fprintf(stderr, "Error occured while trying to determine local address.\n");
		return -1;
	}
	
	// creating the server socket now
	// int socket(int domain, int type, int protocol);
	server_socket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (server_socket < 0) {
	  perror("socket");
	  return -1;
	}

	// we allow reusing of sockets (SO_REUSEADDR). Socket level (SOL_SOCKET)
	// int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
	reuse = 1;
	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
	// set the socket to non-blocking
	SetNonblocking(server_socket);
	
	// bind the server socket to the address, based on the reply of getaddrinfo()
	// int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	if (bind(server_socket, res->ai_addr, res->ai_addrlen) < 0) {
	  perror("bind");
	  return -1;
	}

	// let's listen for a connection
	// int listen(int sockfd, int backlog);
	if(listen(server_socket, 5) < 0) {
		perror("listen");
		return 1;
	}
	
	// we don't need the address linked list generated by getadrrinfo() anymore
	freeaddrinfo(res);
	
	// initialize the clients array
	for (i=0; i<MAX_CHAT_CLIENTS; i++) {
		chat_clients[i].socket=0;
		chat_clients[i].status=DISCONNECTED;
	}
	
	// initilaize the saved passwords db
	for (i=0; i<MAX_SAVED_PASSWORDS; i++) {
		bzero(passwords[i].nickname, MAX_NICK_LENGTH);
		bzero(passwords[i].password_sha512, 129);
	}
	
	// load passwords from disk
	if (LoadPasswordsFromDisk())
		printf("Failed to to read passwords from file.\n");
	
	
	// register new handler for SIGTERM: QuitGracefully()
	new_signal_action.sa_handler = QuitGracefully;
	sigemptyset (&new_signal_action.sa_mask);
	new_signal_action.sa_flags = 0;
	sigaction(SIGTERM, &new_signal_action, NULL);
	
	// allocate memory for the client socket list
	/*
	memset((char *) &connected_client_socks, 0, sizeof(connected_client_socks));
	*/

	// main loop, we iterate through the sockets
	// accept connections if needed, read them if needed, giving them a small timeout	
	while (1)
	{
		BuildSelectList();
		select_timeout.tv_sec = 1;
		select_timeout.tv_usec = 0;
		// run the select. it will return if 
		// a) it can read from the set of sockets in socks_to_process (or EOF if disconnected)
		// b) after timeout
		num_of_sockets_to_read = select(FD_SETSIZE, &socks_to_process, (fd_set *) 0, (fd_set *) 0, &select_timeout);
		
		// select has modified socks_to_process, only those remain which can be read without blocking
		if (0 == num_of_sockets_to_read) {
			#ifdef DEBUG
			// show that it works
			printf("*");
			#endif
			fflush(stdout);
		}
		else {
			#ifdef DEBUG
			// show that it works
			printf("\n");
			#endif		
			ProcessSocketsToRead();
		}
	}
}


// creates the set of sockets that select needs to iterate through
// to be called from the main loop
void BuildSelectList() {
	int i;
	// empty the set
	FD_ZERO(&socks_to_process);
	
	// add the server socket
	FD_SET(server_socket, &socks_to_process);
	
	// add the client sockets which are connected
	for(i=0; i<MAX_CHAT_CLIENTS; i++) 
		if (0 != chat_clients[i].socket) 
			FD_SET(chat_clients[i].socket,&socks_to_process);
}

// if we detect a new incoming connection, let's accept it if we have an empty slot
void HandleNewConnection(void) {
	int i;
	int client_socket;
	int getnameinfo_error;
	short connection_accepted = 0;
	struct sockaddr_in6 addr;
	socklen_t addrlen;	
	char ips[NI_MAXHOST];
	char servs[NI_MAXSERV];	
	const char msg_server_full[]="Sorry, the chat server is currently full. Try again later.\n";
	
	client_socket = accept(server_socket, (struct sockaddr*)&addr, &addrlen);
	
	if (client_socket == -1)
		printf("Error occured while trying to accept connection\n");
	
	else {
		SetNonblocking(client_socket);
		// try to get client's ip:port string in a protocol-independent way, using getnameinfo()
		// we need the size of addr
		addrlen = sizeof(addr);
		getnameinfo_error = getnameinfo((struct sockaddr*)&addr, addrlen, ips, sizeof(ips), servs, sizeof(servs), 0);
		// check if there's room for our socket
		for (i=0; (i < MAX_CHAT_CLIENTS) && (0 == connection_accepted); i++)
			if (0 == chat_clients[i].socket) {
				// we found a free slot, let's accept the client connection
				chat_clients[i].socket=client_socket;
				chat_clients[i].status=WAITING_FOR_NICK;
			// reset channel & nickname
				bzero(chat_clients[i].channel, MAX_CHANNEL_LENGTH);
				bzero(chat_clients[i].nickname, MAX_NICK_LENGTH);				
				if (0 == getnameinfo_error) 
					printf("Chat client connection accepted from: %s:%s. Socket descriptor: %d, Socket index: %d\n", ips, servs, client_socket, i);
				else 
					printf("Chat client connection accepted. Cannot display client address, an error occured while looking it up.\n");
				connection_accepted = 1;
			}
		}
		
		if (0 == connection_accepted) {
			// went through all slots, and we couldn't put the new connection in any
			// we need to reject this client then
			if (0 == getnameinfo_error) 
				printf("Rejecting client connection from %s:%s, no free slots.\n", ips, servs);
			else 
				printf("Rejecting client connection. Cannot display client address, an error occured while looking it up.\n");
			send(client_socket, msg_server_full, strlen(msg_server_full), 0);
			close(client_socket);
		}
}

// ProcessPendingRead() to be called when we already know that one client has data to transfer
// Data is read & sent to the other chat clients
void ProcessPendingRead(int clientindex)
{
	int bytes_read;
	//int i;
	
	do {
		// fill buffer with zeros
		bzero(buffer, MAX_SOCKET_BUF);
		// receive the data
		bytes_read = recv(chat_clients[clientindex].socket, buffer, MAX_SOCKET_BUF, 0);
		
		if (0 == bytes_read) {
			// got disconnected from this client
			// there was an EOF, and this is read as 0 byte by recv()
			printf("Disconnected from a client. Socket descriptor: %d, Socket index: %d\n", chat_clients[clientindex].socket, clientindex);
			close(chat_clients[clientindex].socket);
			chat_clients[clientindex].socket = 0;
			chat_clients[clientindex].status = DISCONNECTED;
			// reset channel & nickname
			bzero(chat_clients[clientindex].channel, MAX_CHANNEL_LENGTH);
			bzero(chat_clients[clientindex].nickname, MAX_NICK_LENGTH);

			break;
		}
		
		if (bytes_read > 0) {
			// the connection is healthy
			// and we read data from the client in "buffer"
			
			#ifdef DEBUG
			// add to stdout in debug mode
			printf("A client has sent: %s", buffer);
			#endif
			
			// because of the stream behavior, buffer can have more than one messages from a client
			// these are separated by '\n', as per the protocol specification
			// we will tokenize buffer with separator '\n', and process each message one by one
			char *next_msg;
			next_msg = strtok(buffer, "\n");
			while (next_msg != NULL) {
				// let's see if we got a change nick command from the client
				if ( !(StrBegins(next_msg, "CHANGENICK ")) ) {
					// process the client command
					ProcessClientChangeNick(clientindex, next_msg);
					// done with this token (message), let's move on to the next one
					next_msg = strtok(NULL, "\n");						
					continue;
				}
				
				// let's see if we got a change channel command from the client
				if ( !(StrBegins(next_msg, "CHANGECHANNEL ")) ) {
					// process the client command
					ProcessClientChangeChan(clientindex, next_msg);
					next_msg = strtok(NULL, "\n");		
					continue;
				}
				
				// client setting/changing a pass to protect nick
				if ( !(StrBegins(next_msg, "CHANGEPASS ")) ) {
					// process the client command
					ProcessClientChangePass(clientindex, next_msg);
					next_msg = strtok(NULL, "\n");		
					continue;
				}				
				
				if ( !(StrBegins(next_msg, "CHANMSG ")) ) {
					ProcessClientChanMsg(clientindex, next_msg);
					next_msg = strtok(NULL, "\n");		
					continue;
				}
				
				if ( !(StrBegins(next_msg, "PRIVMSG ")) ) {
					ProcessClientPrivMsg(clientindex, next_msg);
					next_msg = strtok(NULL, "\n");		
					continue;
				}
			
				// if the client command isn't recognized, reply this.
				sprintf(reply, "CMDERROR Unknown command.\n");
				next_msg = strtok(NULL, "\n");				
			}	
		}
		
	} while (bytes_read > 0);
}

// to be called from the main loop
// in the case select reports that there is at least 1 socket that needs to be read
void ProcessSocketsToRead() {
	int i;
	// if there's a new connection request, select() will mark the socket as readable
	if (FD_ISSET(server_socket, &socks_to_process)) 
		HandleNewConnection();
	
	// let's iterate through the sockets
	// if a socket's file descriptor is in the socks_to_process set, then it needs to be read
	for(i=0; i<MAX_CHAT_CLIENTS; i++)
		if (FD_ISSET(chat_clients[i].socket, &socks_to_process))
			ProcessPendingRead(i);
}

// process a change nick command from a client
// if the nick is password protected, will only change nick if the second parameter is the correct pass
// cmd_msg example: CHANGENICK Johnny
// cmd_msg example: CHANGENICK Johnny 55491eb81ee14bf05c87d34b5f1ad9f4c3ee960626dcb9e85d1a0dd87b37b74081fe59a4e5f8ecd772f2aef4d51a2cb1e6d93f3d30c04cbcb3526fe040edfb5d
// will tell others in the old channel about the change nick (CHANUPDATECHANGENICK)
// some reply examples:
//  CHANGENICKOK newnick
void ProcessClientChangeNick(int clientindex, const char *cmd_msg) {
		char newnick[MAX_NICK_LENGTH+1];
		char password_sha512[129];
		int i;
		int password_is_sent=FALSE;
		
		// reset reply string		
		bzero(reply, MAX_SOCKET_BUF);
		
		// get the new nick from the parameters, and also password if it's there
		if (CountParams(cmd_msg) == 1)
			sscanf(cmd_msg, "CHANGENICK %s", newnick);
		else if (CountParams(cmd_msg) == 2) {
			sscanf(cmd_msg, "CHANGENICK %s %[^/n]", newnick, password_sha512);
			password_is_sent=TRUE;
			}
		else {
			sprintf(reply, "CHANGENICKERROR Wrong syntax in nick change command.\n");
			send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
			return;
		}
		
		if (strlen(newnick)>MAX_NICK_LENGTH -1) {
				sprintf(reply, "CHANGENICKERROR Nick is too long.\n");
				send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
				return;
		}
		
		// if client already set a nick before, let's check if this nick is different
		if (chat_clients[clientindex].status != WAITING_FOR_NICK ) {
			if (!strcmp(newnick, chat_clients[clientindex].nickname)) {
				sprintf(reply, "CHANGENICKERROR Your nickname is already %s.\n", newnick);
				send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
				return;
			}
		}
		
		// check if nick is taken
		for (i=0; i<MAX_CHAT_CLIENTS; i++) {
			if (!strcmp(newnick, chat_clients[i].nickname)) {
				sprintf(reply, "CHANGENICKERROR The %s nickname is already taken.\n", newnick);
				send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
				return;
			}
		}
		
		// ok, it wasn't taken
		// let's see if it is a password-protected nick
		for (i=0; i<MAX_SAVED_PASSWORDS; i++) {
			// let's see if this nick is in the password db
			if ( strlen(passwords[i].nickname) > 0 && !strcmp(passwords[i].nickname, newnick)) {
				// yes it's protected. if password wasn't sent, bad luck
				if (!password_is_sent) {
					sprintf(reply, "CHANGENICKERROR Nick %s is password protected, and you haven't sent a password.\n", newnick);
					send(chat_clients[clientindex].socket, reply, strlen(reply), 0);					
					return;
				}
				// they sent a password, now let's compare
				else {
					if (strcmp(passwords[i].password_sha512, password_sha512)) {
						// doesn't match
						sprintf(reply, "CHANGENICKERROR Wrong password.\n");
						send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
						return;
					}	
				}
				break;
			}
		}
		
		// if we got this far, nickname wasn't password protected, or the sent password was correct
		// so we can go ahead with the nick change
	
		// send the current nick updates to the other people in the channel
		// CHANUPDATECHNICK oldnick newnick
		for (i=0; i<MAX_CHAT_CLIENTS; i++) {
			if ( i!=clientindex && chat_clients[i].status == CHATTING && !strcmp(chat_clients[clientindex].channel, chat_clients[i].channel) ) {
				sprintf(reply, "CHANUPDATECHANGENICK %s %s\n", chat_clients[clientindex].nickname, newnick);
				send(chat_clients[i].socket, reply, strlen(reply), 0);
			}
		}
		
		// now we can change the nick of the person
		strcpy(chat_clients[clientindex].nickname, newnick);
		// only have to change status if client hasn't had a nick before
		if ( WAITING_FOR_NICK == chat_clients[clientindex].status )
			chat_clients[clientindex].status = HAS_NICK_WAITING_FOR_CHANNEL;
		sprintf(reply, "CHANGENICKOK %s\n", newnick);
		send(chat_clients[clientindex].socket, reply, strlen(reply), 0);			
		
		// send the updated nick lists to people in the channel (also to the new joiner themselves)
		// when the client will be smarter and will handle CHANUPDATECHNICK better, this won't be needed
		// then we will need to send the complete nicklist only to the new joiner
		if ( strlen(chat_clients[clientindex].channel) > 0 ) 
			BroadcastChanNicklist(chat_clients[clientindex].channel);
}


// process a change channel from a client
// cmd_msg example: CHANGECHANNEL budapest
// will tell others in the old channel about the leaver (CHANUPDATELEAVE)
// and others in the new channel about the new joiner (CHANUPDATEJOIN)
// the client will get a CHANGECHANNELOK on success, and a list of others in the new channel
void ProcessClientChangeChan(int clientindex, const char *cmd_msg) {
	int i;
	// reset reply string
	bzero(reply, MAX_SOCKET_BUF);
	
	// can't join channel without a nickname
	if (chat_clients[clientindex].status == WAITING_FOR_NICK) {
		sprintf(msg_to_send, "CHANGECHANNELERROR Please set a nickname before joining a channel.\n");
		send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);
		return;
	}

	char old_channel[MAX_CHANNEL_LENGTH+1];
	char new_channel[MAX_CHANNEL_LENGTH+1];
	strcpy(old_channel, chat_clients[clientindex].channel);
	sscanf(cmd_msg, "CHANGECHANNEL %s\n", new_channel);
	
	// if this isn't the intial channel join, but a real channel change,
	// send CHANUPDATELEAVE leavernick to other people in the old channel

	if (chat_clients[clientindex].status == CHATTING) {
		for (i=0; i<MAX_CHAT_CLIENTS; i++) {
			if ( i!=clientindex && chat_clients[i].status == CHATTING 
					&& !strcmp(chat_clients[i].channel, chat_clients[clientindex].channel) ) 
			{
				sprintf(reply, "CHANUPDATELEAVE %s\n", chat_clients[clientindex].nickname);
				send(chat_clients[i].socket, reply, strlen(reply), 0);
				bzero(reply, MAX_SOCKET_BUF);
			}
		}
	}
	
	// send CHANUPDATEJOIN joinernick to other people in the new channel
	for (i=0; i<MAX_CHAT_CLIENTS; i++) {
		if ( i!=clientindex && chat_clients[i].status == CHATTING && !strcmp(chat_clients[i].channel, new_channel) ) {
			sprintf(reply, "CHANUPDATEJOIN %s\n", chat_clients[clientindex].nickname);
			send(chat_clients[i].socket, reply, strlen(reply), 0);
			bzero(reply, MAX_SOCKET_BUF);
		}
	}
	
	// now we can change the channel of the person
	strcpy(chat_clients[clientindex].channel, new_channel);
	chat_clients[clientindex].status = CHATTING;
	sprintf(reply, "CHANGECHANNELOK %s\n", new_channel);
	send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
	bzero(reply, MAX_SOCKET_BUF);
	
	// send the updated nick lists to people in the old chan
	if ( strlen(old_channel) > 0 ) 
		BroadcastChanNicklist(old_channel);
	// send the updated nick lists to people in the new chan (including the person who changed channel)
	// when the client will be smarter and will handle CHANUPDATELEAVE CHANUPDATEJOIN better, this won't be needed
	// then we will need to send the complete nicklist only to the person who changed channels
	BroadcastChanNicklist(new_channel);
	
	return;
	
	// if the CMD line didn't fit any of the commands, it has wrong syntax, reply this.
	sprintf(reply, "CMDERROR Unknown command.\n");
}

// will send the new nicklist using CHANUPDATEALLNICKS to all people in the channel
// format: CHANUPDATEALLNICKS nick1 nick2 etc
// if too many nicks are in the channel, multiple CHANUPDATEALLNICKS messages will be sent
void BroadcastChanNicklist(const char* channel) {
	int i, j;
	sprintf(reply, "CHANUPDATEALLNICKS");	
	// gather all nicks in the new channel
	for (i=0; i<MAX_CHAT_CLIENTS; i++) {
		if ( chat_clients[i].status == CHATTING && !strcmp(chat_clients[i].channel, channel) )
		{
			// if one more nick fits the reply currently being built, add it
			if ((strlen(reply) + 1 + strlen(chat_clients[i].nickname)) < MAX_SOCKET_BUF-1 ) {
				strcat(reply, " ");
				strcat(reply, chat_clients[i].nickname);
			}
			// reply would be too long, so let's send the current reply, and start building a new one
			else {
				strcat(reply, "\n");
				for (j=0; j<MAX_CHAT_CLIENTS; j++) {
					if ( chat_clients[j].status == CHATTING && !strcmp(chat_clients[j].channel, channel) )
					{
						send(chat_clients[j].socket, reply, strlen(reply), 0);
					}
				}
				// ok the last long reply is sent
				// let's start building the new reply
				sprintf(reply, "CHANUPDATEALLNICKS");
				strcat(reply, " ");
				strcat(reply, chat_clients[i].nickname);				
			}
		}
	}
	
	// ok now we have the last reply (could be the first at the same time)
	// let's add the closing \n, and send to everyone in the new channel
	strcat(reply, "\n");
	for (i=0; i<MAX_CHAT_CLIENTS; i++) {
		if ( chat_clients[i].status == CHATTING && !strcmp(chat_clients[i].channel, channel) )
		{
			send(chat_clients[i].socket, reply, strlen(reply), 0);
		}
	}
}

// process a change pass command from a client
// cmd_msg example: CHANGEPASS mynewpass
// only someone with a nickname can change nick password
// which means they are already verified as the rightful owner of the nick
// some reply examples:
//  CHANGEPASSOK nickname
//  CHANGEPASSERROR You cannot set a nickname password without a nickname. Please set a nick first.
void ProcessClientChangePass(int clientindex, const char *cmd_msg) {
	int i;
	// reset reply string
	bzero(reply, MAX_SOCKET_BUF);
	char newpass_sha512[129];
	sscanf(cmd_msg, "CHANGEPASS %s", newpass_sha512);
	
	// make sure they already have a nickname
	// if it's a registered nickname that they hold, it means they are authorized to use it, because CHANGENICK makes sure of that
	if (chat_clients[clientindex].status == WAITING_FOR_NICK ) {
		sprintf(reply, "CHANGEPASSERROR Cannot set a nickname password without a nickname.\n");
		send(chat_clients[clientindex].socket, reply, strlen(reply), 0);
		return;
	}
	
	// ok we can update password
	// let's see if he's already in the password db
	for (i=0; i<MAX_SAVED_PASSWORDS; i++) {
		if (!strcmp(chat_clients[clientindex].nickname, passwords[i].nickname)) {
			// we found the person in the passwords database, let's update their pass
			strcpy(passwords[i].password_sha512, newpass_sha512);
			sprintf(reply, "CHANGEPASSOK %s\n", chat_clients[clientindex].nickname);
			send(chat_clients[clientindex].socket, reply, strlen(reply), 0);				
			return;
		}
	}
	
	// if we got this far, he isn't in the pass db, let's look for a free spot
	for (i=0; i<MAX_SAVED_PASSWORDS; i++) {
		if (strlen(passwords[i].nickname)==0) {
			// we found a free spot, let's update save his password
			strcpy(passwords[i].nickname, chat_clients[clientindex].nickname);
			strcpy(passwords[i].password_sha512, newpass_sha512);
			// update the passwords file on the disk too
			if (SavePasswordsToDisk())
					printf("Failed to open termchatpasswd file for saving passwords to disk!\n");
			sprintf(reply, "CHANGEPASSOK %s\n", chat_clients[clientindex].nickname);
			send(chat_clients[clientindex].socket, reply, strlen(reply), 0);				
			return;
		}
	}
	
	sprintf(reply, "CHANGEPASSERROR Sorry, server password database is full.\n");
	send(chat_clients[clientindex].socket, reply, strlen(reply), 0);					
	
}


// process a channel message that we got from a chat client
// if we can accept the channel message, we relay it to others in the channel
// and also to the sender - this serves as a acknowledgement of delivery
// if we cannot accept the channel message, then we send a CHANMSGERROR
void ProcessClientChanMsg(int clientindex, const char *chan_msg) {
	int i;
	// reset msg_to_send string
	bzero(msg_to_send, MAX_SOCKET_BUF);	
	
	// we don't accept channel messages, if the client hasn't set a nickname yet
	if (chat_clients[clientindex].status == WAITING_FOR_NICK) {
		sprintf(msg_to_send, "CHANMSGERROR Please set a nickname, and set the channel first.\n");
		send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);
		return;
		}
	
	// client has set a nickname, but they also have to set the channel before sending channel msgs
	if (chat_clients[clientindex].status == HAS_NICK_WAITING_FOR_CHANNEL) {
		sprintf(msg_to_send, "CHANMSGERROR Please set the channel first.\n");
		send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);
		return;
	}
	
	// ok, so the client has a nick and is in a channel, we accept the channel message
	char *channel = chat_clients[clientindex].channel;
	
	// we got the message in format: CHANMSG hi there
	// we send it back to the people in the channel in format: CHANMSGFROM sendernick hi there
	// let's build the new message to send based on the original
	sprintf(msg_to_send, "CHANMSGFROM %s %s\n", chat_clients[clientindex].nickname, chan_msg+8);		
	
	// go through every client, and send them the message if they're in the particular channel
	// even the source, so he knows that their message has been delivered
	for (i=0; i < MAX_CHAT_CLIENTS; i++) {
		 if (!strcmp(channel, chat_clients[i].channel))
			send(chat_clients[i].socket, msg_to_send, strlen(msg_to_send), 0);
	}	
}

// process a private message that we got from a chat client
// format: PRIVMSG targetnick message
// if we can accept the channel message, we relay it to the recepient
// in format: PRIVMSGFROM sourcenick message
// sender will get back a PRIVMSGOK targetnick message as an acknowledgement
// or a PRIVMSGERROR error message
void ProcessClientPrivMsg(int clientindex, const char *priv_msg) {	
	int i;
	char target_nick[MAX_NICK_LENGTH+1];
	char message[MAX_MSG_LENGTH+1];
	
	// reset msg_to_send string
	bzero(msg_to_send, MAX_SOCKET_BUF);	
	
	// we don't accept private messages, if the client hasn't set a nickname yet
	if (chat_clients[clientindex].status == WAITING_FOR_NICK) {
		sprintf(msg_to_send, "PRIVMSGERROR Please set a nickname before sending a private message.\n");
		send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);
		return;
	}
	
	// get the target nick & the actual message
	sscanf(priv_msg, "PRIVMSG %s %[^\n]", target_nick, message);
	// go through every client
	for (i=0; i < MAX_CHAT_CLIENTS; i++) {			
		if (!strcmp(target_nick, chat_clients[i].nickname)) {
			// we found the target nick, send him the PRIVMSGFROM sourcenick message
			sprintf(msg_to_send, "PRIVMSGFROM %s %s\n", chat_clients[clientindex].nickname, message);
			send(chat_clients[i].socket, msg_to_send, strlen(msg_to_send), 0);
			// now send the ack to the sender, PRIVMSGOK targetnick message
			bzero(msg_to_send, MAX_SOCKET_BUF);
			sprintf(msg_to_send, "PRIVMSGOK %s %s\n", target_nick, message);
			send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);
			return;
		}
	}

	// if we get this far, that means we couldn't find the target nick
	sprintf(msg_to_send, "PRIVMSGERROR Can't deliver message, no user named '%s' is online.\n", target_nick);
	send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0);		
}

// for sending channel, control, error messages to clients
// it pads all messages with the message separator; \n
// returns 0 if all ok, -1 if there was a problem
int SendMsgToClient(int clientindex, const char *msg) {
	// each message needs to characters as the message separators, which needs to fit in MAX_SOCKET_BUF
	if (strlen(msg) > (MAX_SOCKET_BUF-2))
		return -1;
	bzero(msg_to_send, MAX_SOCKET_BUF);
	strcpy(msg_to_send, msg);
	strcat(msg_to_send, "\n");
	
	if (-1 == send(chat_clients[clientindex].socket, msg_to_send, strlen(msg_to_send), 0))
		return (-1);
	else return 0;
}


// if we receive a SIGTERM signal, send a cozy quit message
void QuitGracefully(int signum) {
	int i;
	// close server & client sockets
	close(server_socket);
	for (i=0; i < MAX_CHAT_CLIENTS; i++) {
		if (0 != chat_clients[i].socket) {
			close(chat_clients[i].socket);
		}
	}
	printf("Termchatserver was terminated. Goodbye!\n");
	exit(signum);
}


// will save passwords to disk
// format for each password line: nickname passwordsha512\n
// if problem arises, -1 will be returned
int SavePasswordsToDisk(void) {
	int i;
	int fd;
	int characters_written;
	fd = open("termchatpasswd", O_CREAT | O_TRUNC | O_WRONLY, 0600);
	if (fd < 0) {
		perror("open");		
		return -1;

	}
	
	// go through password db
	for (i=0; i<MAX_SAVED_PASSWORDS; i++) {
		if (strlen(passwords[i].nickname)!=0) {
			// write the nickname
			characters_written = write(fd, passwords[i].nickname, MAX_NICK_LENGTH);
			if (characters_written == -1) {
				perror("write");
				return -1;
			}
			// a space
			characters_written = write(fd, " ", 1);
			if (characters_written == -1) {
				perror("write");
				return -1;
			}
			// the pass sha512 hex value
			characters_written = write(fd, passwords[i].password_sha512, 128);
			if (characters_written == -1) {
				perror("write");
				return -1;
			}
			// new line character
			characters_written = write(fd, "\n", 1);
			if (characters_written == -1) {
				perror("write");
				return -1;
			}			
		}
	}
	close(fd);
	#ifdef DEBUG		
	printf("Written the termchatpasswd file.\n");
	#endif			
	return(0);
}

int LoadPasswordsFromDisk(void) {
	int fd;
	char nickname_from_file[MAX_NICK_LENGTH+1];
	char password_sha512_from_file[129];
	char tmp_character[1];
	int characters_read;
	int currently_processing = 0;

	fd = open("termchatpasswd",  O_RDONLY);
	if (fd < 0) {
		perror("open");
		return -1;
	}

	while ( currently_processing < MAX_SAVED_PASSWORDS ) {
		// read a nickname
		characters_read = read(fd, nickname_from_file, MAX_NICK_LENGTH);
		// error
		if (characters_read == -1) {
			perror("read");
			return -1;
		}
		// end of file
		if (characters_read == 0) {
			break;
		}
		nickname_from_file[MAX_NICK_LENGTH]='\0';
		#ifdef DEBUG
		printf("Read nick from termchatpasswd file: %s\n", nickname_from_file);
		#endif

		// read the space separator
		characters_read = read(fd, tmp_character, 1);
		// error
		if (characters_read == -1) {
			perror("read");
			return -1;			
		}
		// end of file
		if (characters_read == 0) {
			break;
		}  

		// read the password sha512 hex string
		characters_read = read(fd, password_sha512_from_file, 128);
		// error
		if (characters_read == -1) {
			perror("read");
			return -1;			
		}
		// end of file
		if (characters_read == 0) {
			break;
		}
		password_sha512_from_file[128]='\0';
		#ifdef DEBUG		
		printf("Read hash from termchatpasswd file: %s\n", password_sha512_from_file);
		#endif		

		// read the new line character
		characters_read = read(fd, tmp_character, 1);
		// error
		if (characters_read == -1) {
			perror("read");
			return -1;			
		}
		// end of file
		if (characters_read == 0) {
			break;
		}
		
		// we managed to read a complete line from the termchatpasswd line
		// add it to memory
		strcpy(passwords[currently_processing].nickname, nickname_from_file);
		strcpy(passwords[currently_processing].password_sha512, password_sha512_from_file);
		
		currently_processing++;	
	}

	close(fd);
	return 0;	
}
